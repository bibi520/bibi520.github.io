<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bibi520.github.io</id>
    <title>bibi</title>
    <updated>2020-03-23T08:17:13.856Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bibi520.github.io"/>
    <link rel="self" href="https://bibi520.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://bibi520.github.io/images/avatar.png</logo>
    <icon>https://bibi520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, bibi</rights>
    <entry>
        <title type="html"><![CDATA[kubernetes的RBAC]]></title>
        <id>https://bibi520.github.io/post/kubernetes-de-rbac/</id>
        <link href="https://bibi520.github.io/post/kubernetes-de-rbac/">
        </link>
        <updated>2020-03-18T09:07:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="创建一个test只有get权限">创建一个test只有get权限</h3>
<ol>
<li>生成用户私钥<br>
<code>(umask 077; openssl genrsa -out test.key 2048)</code></li>
<li>生成用户证书<br>
<code>openssl req -new -key test.key -out test.csr -subj &quot;/CN=test&quot;</code></li>
<li>签发证书(使用服务端证书去签发)<br>
<code>openssl x509 -req -in test.csr -CA kube-ca.pem -CAkey kube-ca-key.pem -CAcreateserial -out test.crt -days 365</code></li>
<li>设置客户端认证<br>
<code>kubectl config set-credentials test --client-certificate=./test.crt --client-key=./test.key --embed-certs=true</code></li>
<li>设置上下文<br>
<code>kubectl config set-context test --cluster=local --user=test</code></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[kubernetes的job和conjob]]></title>
        <id>https://bibi520.github.io/post/kubernetes-de-conjob/</id>
        <link href="https://bibi520.github.io/post/kubernetes-de-conjob/">
        </link>
        <updated>2020-03-18T03:20:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="job">Job</h3>
<ul>
<li>.spec.template格式同pod</li>
<li>RestartPolicy仅支持Never和OnFailure</li>
<li>单个Pod时，默认Pod成功运行后Job即结束</li>
<li>.spec.completions标志Job结束需要成功运行的Pod个数，默认为1</li>
<li>.spec.parallelism标志并行运行的Pod的个数，默认为1</li>
<li>spec.activeDeadlineSeconds标志失败Pod的重试最大时间，超过这个时间不会继续重试<br>
例子：</li>
</ul>
<pre><code>apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  template:
    metadata:
      name: pi
    spec:
      containers:
      - name: pi
        image: perl
        command: [&quot;perl&quot;,  &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;]
      restartPolicy: Never
</code></pre>
<h3 id="cronjob-spec">CronJob Spec</h3>
<p>.spec.schedule: 调度，必须字段，指定任务运行周期<br>
.spec.jobTemplate: job模板，必须字段，指定需要运行的任务，格式通job<br>
.spec.startingDeadlineSeconds: 启动job的期限，该字段是可选的。如果因为任何原因错过了被调度的时间，那么错过时间的job将被认定为失败的。如果没指定，则没有期限。<br>
.spec.concurrencyPolicy: 并发策略，该字段也是可选的。<br>
* Allow（默认）：允许并行job<br>
* Forbid：禁止并发运行，如果前一个还没完成，则直接跳过下一个<br>
* Replace：取消当前正在运行的job，用一个新的来替代<br>
.spec.suspend: 挂起，该字段也是可选的。如果设置为true，后续所有执行操作都会挂起，他对已经开始的job不起作用。默认值为：false<br>
.spec.successfulJobsHistoryLimit和.spec.failedJobsHistoryLimit: 历史限制，可选字段。它指定可以保留多少个完成和失败的job。<br>
例子：</p>
<pre><code>apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: hello
spec:
  schedule: &quot;*/1 * * * *&quot;
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox
            args:
            - /bin/sh
            - -c
            - date; echo Hello from the Kubernetes cluster
          restartPolicy: OnFailure
</code></pre>
<h3 id="cron-job的时间表达式">Cron Job的时间表达式</h3>
<ul>
<li>Minutes：可出现&quot;,&quot;  &quot;_&quot;  &quot;*&quot;  &quot;/&quot;  这个四个字符串，有效范围为0~59的整数</li>
<li>Hours：可出现&quot;,&quot;  &quot;_&quot;  &quot;*&quot;  &quot;/&quot;  这个四个字符串，有效范围为0~23的整数</li>
<li>DayofMonth：可出现&quot;,&quot;  &quot;_&quot;  &quot;*&quot;  &quot;/&quot;  &quot;?&quot;  &quot;L&quot;  &quot;W&quot;  &quot;C&quot;  这8个字符，有效范围为0~31的整数</li>
<li>Month：可出现&quot;,&quot;  &quot;_&quot;  &quot;*&quot;  &quot;/&quot;  这个四个字符串，有效范围为1~12的整数</li>
<li>DayofWeek：可出现&quot;,&quot;  &quot;_&quot;  &quot;*&quot;  &quot;/&quot;  &quot;?&quot;  &quot;L&quot;  &quot;C&quot;  &quot;#&quot; 这个8个字符，有效范围为1~7的整数</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[tekton和triggers学习]]></title>
        <id>https://bibi520.github.io/post/tekton-xue-xi/</id>
        <link href="https://bibi520.github.io/post/tekton-xue-xi/">
        </link>
        <updated>2020-03-16T08:55:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="tekton-5种资源">tekton 5种资源</h3>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://github.com/tektoncd/pipeline/blob/v0.11.0-rc2/docs/tasks.md">task</a></td>
<td style="text-align:center">定义一系列运行任务</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/tektoncd/pipeline/blob/v0.11.0-rc2/docs/taskruns.md">TaskRun</a></td>
<td style="text-align:center">task 实际的执行, 并提供执行所需的参数. 这个对象创建后, 就会有 pod 被创建.</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/tektoncd/pipeline/blob/v0.11.0-rc2/docs/pipelines.md">Pipeline</a></td>
<td style="text-align:center">定义一个或者多个 task 的执行, 以及 PipelineResource 和各种定义参数的集合</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/tektoncd/pipeline/blob/v0.11.0-rc2/docs/resources.md">PipelineResource	</a></td>
<td style="text-align:center">流水线的输入资源, 比如 github/gitlab 的源码, 某种存储服务的文件, 或者镜像等. 执行时, 也会作为 pod 的其中一个 container 来运行(比如拉取代码).</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://github.com/tektoncd/pipeline/blob/v0.11.0-rc2/docs/pipelineruns.md">PipelineRun</a></td>
<td style="text-align:center">类似 task 和 taskrun 的关系: 一个定义一个执行. PipelineRun 则是 pipeline 的实际执行. 创建后也会创建 pod 来执行各个 task.</td>
</tr>
<tr>
<td style="text-align:center">Condition</td>
<td style="text-align:center">在 pipeline 的 task 执行时通过添加 condition 来对条件进行评估, 进而判断是否执行 task.</td>
</tr>
</tbody>
</table>
<h3 id="实例">实例</h3>
<pre><code>apiVersion: tekton.dev/v1alpha1
kind: Task
metadata:
  name: appweb-develop-task
spec:
  inputs:
    resources:
    - name: workspace
      type: git
  steps:
  - name: node-install-build
    image: node:latest
    workingDir: /workspace/workspace
    command: ['/bin/bash']
    args: 
    - -c
    - |
      npm i 
      npm run build
    volumeMounts:
    - name: nms
      mountPath: /workspace/workspace/node_modules
    - name: docker-config
      mountPath: /kaniko/.docker/
  - name: docker-build
    image: gcr.io/kaniko-project/executor:v0.17.1  
    command:
    - /kaniko/executor
    args:
    - --dockerfile=/workspace/workspace/Dockerfile
    - --context=/workspace/workspace
    - --destination=registry.us-west-1.aliyuncs.com/chocolate/base
    - --insecure
    securityContext:
      runAsUser: 0
  volumes:
  - name: nms
    hostPath:
      path: /root/node_modules
  - name: docker-config
    configMap:
      name: docker-config
---
apiVersion: tekton.dev/v1alpha1
kind: Pipeline
metadata:
  name: appweb-develop-pipeline
spec:
  resources:
  - name: source-repo
    type: git
  tasks:
  - name: flow
    taskRef:
      name: appweb-develop-task
    resources:
      inputs:
      - name: workspace
        resource: source-repo
---
apiVersion: tekton.dev/v1alpha1
kind: PipelineResource
metadata:
  name: appweb-develop-resource
spec:
  type: git
  params:
  - name: revision
    value: develop
  - name: url
    value: http://x.x.x.x/web/ztime
---
</code></pre>
<h3 id="triggers"><a href="https://github.com/tektoncd/triggers">triggers</a> 四种资源</h3>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TriggerTemplate</td>
<td style="text-align:center">创建PipelineResources and PipelineRun的运行模板</td>
</tr>
<tr>
<td style="text-align:center">TriggerBinding</td>
<td style="text-align:center">验证或是提取拦截器返回的字段</td>
</tr>
<tr>
<td style="text-align:center">EventListener</td>
<td style="text-align:center">需要监听的git地址</td>
</tr>
<tr>
<td style="text-align:center">ClusterTriggerBinding</td>
<td style="text-align:center">同TriggerBinding一样，不同的是这个集群范围的</td>
</tr>
</tbody>
</table>
<p>实例：</p>
<pre><code>---
apiVersion: tekton.dev/v1alpha1
kind: TriggerBinding
metadata:
  name: appweb-develop-pipeline-binding
spec:
  params:
  - name: revision
    value: $(body.ref)
  - name: url
    value: $(body.project.git_http_url)
---
apiVersion: tekton.dev/v1alpha1
kind: TriggerTemplate
metadata:
  name: appweb-develop-pipeline-template
spec:
  params:
  - name: revision
  - name: url
  resourcetemplates:
  - apiVersion: tekton.dev/v1alpha1
    kind: PipelineRun
    metadata:
      generateName: appweb-develop-pipeline-run-
    spec:
      pipelineRef:
        name: appweb-develop-pipeline
      serviceAccountName: default
      resources:
      - name: source-repo
        resourceRef:
          name: appweb-develop-resource
      params:
      - name: uid
        value: $(uid)

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tekton-trigger
secrets:
  - name: default-token-752h4
  - name: gitlab
  - name: tekton-trigger-token-vbrc4 
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tekton-trigger
rules:
# Permissions for every EventListener deployment to function
- apiGroups: [&quot;tekton.dev&quot;]
  resources: [&quot;eventlisteners&quot;, &quot;triggerbindings&quot;, &quot;triggertemplates&quot;,&quot;tasks&quot;,&quot;taskruns&quot;,&quot;pipelineruns&quot;]
  verbs: [&quot;get&quot;,&quot;create&quot;]
- apiGroups: [&quot;&quot;]
  resources: [&quot;configmaps&quot;, &quot;secrets&quot;] # secrets are only needed for Github/Gitlab interceptors
  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
# Permissions to create resources in associated TriggerTemplates
- apiGroups: [&quot;tekton.dev&quot;]
  resources: [&quot;pipelineruns&quot;, &quot;pipelineresources&quot;, &quot;taskruns&quot;]
  verbs: [&quot;create&quot;,&quot;get&quot;]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tekton-trigger
subjects:
- kind: ServiceAccount
  name: tekton-trigger
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: tekton-trigger
</code></pre>
<p>创建一个EventListener：</p>
<pre><code>---
apiVersion: tekton.dev/v1alpha1
kind: EventListener
metadata:
  name: listener-interceptor
spec:
  serviceAccountName: &quot;tekton-trigger&quot;
  triggers:
    - name: foo-trig
      interceptors:
        - gitlab:
            secretRef:
              secretName: x-gitlab-token
              secretKey: gitlabToken
            eventTypes:
              - Push Hook
      bindings:
        - name: appweb-develop-pipeline-binding
      template:
        name: appweb-develop-pipeline-template
---
apiVersion: v1
kind: Secret
metadata:
  name: x-gitlab-token
type: Opaque
stringData:
  gitlabToken: hello
</code></pre>
<p>上面secret的gitlab的token指的是钩子的Secret Token，gitlabToken的值如果不行就换成base64加密一下<br>
<img src="https://bibi520.github.io/post-images/1584951102861.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[kubernetes亲和性]]></title>
        <id>https://bibi520.github.io/post/kubernetes-qin-he-xing/</id>
        <link href="https://bibi520.github.io/post/kubernetes-qin-he-xing/">
        </link>
        <updated>2020-03-13T03:00:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="nodeaffinitynode亲和性调度">NodeAffinity：node亲和性调度</h3>
<p>RequiredDuringSchedulingIgnoredDuringExecution：必须满足指定的规则才可以调度pod到node上（相当于硬限制）</p>
<p>PreferredDuringSchedulingIgnoredDuringExecution：强调优先满足指定规则，调速器尝试调度pod到该node上，但并不强求，相当于软连接。多个优先级规则还可以设置权重（weight）值，以定义执行的先后顺序</p>
<p>NodeAffinity规则设置注意事项：</p>
<ol>
<li>如果同时定义了nodeselector和Nodeaffinity，那么必须两个条件都得到满足，pod才能调度该node上去</li>
<li>如果nodeaffinity指定了多个nodeselectorTerms，满足其中一个即可</li>
<li>如果在nodeselectorTerms中有多个matchExpressions，则一个节点必须满足所有matchExpressions才能运行pod</li>
</ol>
<h3 id="podaffinitypod亲和性与互斥策略">PodAffinity：Pod亲和性与互斥策略</h3>
<p>和节点的亲和性相同，pod亲和性与互斥的条件设置也是RequiredDuringSchedulingIgnoredDuringExecution和PreferredDuringSchedulingIgnoredDuringExecution</p>
<p>PodAffinity规则注意事项：</p>
<ol>
<li>除了设置Label selector 和topologyKey，用户还可以指定namespace列表来进行限制，同样，使用Label selector 对namespace进行选择。namespace的定义和Label selector 及topology同级。省略Namespace的设置，表示使用定义了affinity和anti-affinity的pod所在的namespace。如何namespace被设置为控制(&quot;&quot;),则表示所有的namespace。</li>
<li>在所有关联RequiredDuringSchedulingIgnoredDuringExecution的matchExpression全都满足之后，系统才能将pod调度都某个节点上。</li>
</ol>
<h3 id="下面是在这个节点上-只能存在一个标签为app-值等于efficientnet_watch_recognize的pod">下面是在这个节点上  只能存在一个标签为app 值等于efficientnet_watch_recognize的pod</h3>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: efficientnet_watch_recognize
  labels:
    app: efficientnet_watch_recognize
    version: master
spec:
  replicas: 1
  selector:
    matchLabels:
      app: efficientnet_watch_recognize
      version: master
  template:
    metadata:
      labels:
        app: efficientnet_watch_recognize
        version: master
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: kubernetes.io/hostname
                operator: In
                values:
                - 10.0.1.5
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - efficientnet_watch_recognize
            topologyKey: kubernetes.io/hostname
      containers:
      - name: efficientnet_watch_recognize
        image: nginx
        # ports:
        # - containerPort: 8080
        volumeMounts:
        - mountPath: /persistentvolumes/logs
          name: nfs_logs
         - mountPath: /persistentvolumes/images
          name: nfs_images
#      nodeSelector:
#        GPU: &quot;true&quot;
      tolerations:
      - key: &quot;GPU&quot;
        operator: &quot;Equal&quot;
        value: &quot;true&quot;
        effect: &quot;NoSchedule&quot;
      volumes:
      - name: nfs_logs
        nfs:
          path: /logs
          server: 10.0.1.31
      - name: nfs_images
        nfs:
          path: /images
          server: 10.0.1.31
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python爬取实例1]]></title>
        <id>https://bibi520.github.io/post/python-pa-qu-tu-pian/</id>
        <link href="https://bibi520.github.io/post/python-pa-qu-tu-pian/">
        </link>
        <updated>2020-03-12T08:57:46.000Z</updated>
        <content type="html"><![CDATA[<h4 id="仅供学习参考">仅供学习参考</h4>
<pre><code>import  requests,time,threading,os,random
from lxml import etree
from queue import Queue
os.chdir('picture')
headers = {
    'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36 QIHU 360SE'
}
# 创建一个先进先出队列
detail_url_queue = Queue()

#  抓取图片地址并下载
def get_picture(queue):
    while not detail_url_queue.empty():
        url = queue.get()
        print(url)
        html = requests.get(url,headers=headers)
        html.encoding = 'gbk'
        selector = etree.HTML(html.text)
        pic = selector.xpath('//ul[@class=&quot;clearfix&quot;]//li//img//@src')
        for i in pic:
            href = &quot;http://pic.netbian.com&quot;+ i
            content = requests.get(href,headers=headers).content
            with open('{}.jpg'.format(random.random()),'wb') as p:
                p.write(content)
# 获取图片列表页
def get_url(queue):
    for i in range(1,5000):
        queue.put(&quot;http://pic.netbian.com/4kdongman/index_{}.html&quot;.format(i))

if __name__ == &quot;__main__&quot;:
    start_time = time.time()
    t = threading.Thread(target=get_url(detail_url_queue)) #开启一个线程去抓取图片列表页
    t2 = threading.Thread(target=get_picture(detail_url_queue)) #开启一个线程去抓取图片

    t.start()
    t2.start()

    t.join()
    t2.join()
    print(&quot;last time: {} s&quot;.format(time.time()-start_time))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux命令]]></title>
        <id>https://bibi520.github.io/post/linux-ming-ling/</id>
        <link href="https://bibi520.github.io/post/linux-ming-ling/">
        </link>
        <updated>2020-03-12T03:29:05.000Z</updated>
        <content type="html"><![CDATA[<h4 id="auditctl用于配置与审计相关的内核选项">auditctl用于配置与审计相关的内核选项</h4>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-w</td>
<td style="text-align:center">需要监控的文件或是命令</td>
</tr>
<tr>
<td style="text-align:center">-p</td>
<td style="text-align:center">指定监控属性</td>
</tr>
<tr>
<td style="text-align:center">-k</td>
<td style="text-align:center">设置一个关键字用于查询</td>
</tr>
</tbody>
</table>
<h4 id="ausearch查看审计日志">ausearch查看审计日志</h4>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">只显示id为指定数字的日志信息</td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td style="text-align:center">只显示和命令相关的信息</td>
</tr>
<tr>
<td style="text-align:center">-i</td>
<td style="text-align:center">显示详细信息</td>
</tr>
<tr>
<td style="text-align:center">-k</td>
<td style="text-align:center">查看带有关键字的信息</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[helm搭建istio1.5]]></title>
        <id>https://bibi520.github.io/post/helm-da-jian-istio15/</id>
        <link href="https://bibi520.github.io/post/helm-da-jian-istio15/">
        </link>
        <updated>2020-03-11T03:19:12.000Z</updated>
        <content type="html"><![CDATA[<h4 id="准备好kubernetes和helm搭建过程略过">准备好kubernetes和helm（搭建过程略过）</h4>
<h4 id="1下载istio安装包">1.下载istio安装包</h4>
<p><code>curl -L https://istio.io/downloadIstio | sh -</code></p>
<h4 id="2安装istio所需的要的crd以为这个我开启了自动签发证书所以要把certmanager开启">2.安装istio所需的要的CRD(以为这个我开启了自动签发证书，所以要把certmanager开启)</h4>
<p><code>helm install install/kubernetes/helm/istio-init --name istio-init --namespace istio-system --set certmanager.enabled=true</code></p>
<h4 id="3安装sitio-cni网络插件">3.安装sitio-cni网络插件</h4>
<p><code>helm install install/kubernetes/helm/istio-cni --name istio-cni --namespace kube-system</code></p>
<h4 id="4配置kiali和grafana用户和密码-官方例子">4.配置kiali和grafana用户和密码, <a href="https://istio.io/docs/tasks/observability/kiali/">官方例子</a></h4>
<pre><code class="language-apiVersion:">kind: Secret
metadata:
  name: kiali
  namespace: istio-system
  labels:
    app: kiali
type: Opaque
data:
  username: YWRtaW4=
  passphrase: Y2hhbXBzYTg4OA==
---
apiVersion: v1
kind: Secret
metadata:
  name: grafana
  namespace: istio-system
  labels:
    app: grafana
type: Opaque
data:
  username: YWRtaW4=
  passphrase: Y2hhbXBzYTg4OA==
</code></pre>
<h4 id="5安装过istio这里设置好的参数可以到官网查看含义">5.安装过istio这里设置好的参数可以到<a href="https://istio.io/docs/reference/config/installation-options/">官网</a>查看含义</h4>
<p><code>helm install install/kubernetes/helm/istio --name istio --namespace istio-system --set istio_cni.enabled=true --set global.disablePolicyChecks=false --set global.k8sIngress.enabled=true --set global.k8sIngress.enableHttps=true --set global.k8sIngress.gatewayName=ingressgateway --set security.citadelHealthCheck=true --set gateways.enabled=true --set gateways.istio-egressgateway.enabled=true --set gateways.istio-ingressgateway.enabled=true --set gateways.istio-ingressgateway.sds.enabled=true --set certmanager.enabled=true --set certmanager.email=txy@cztec.com --set grafana.enabled=true --set grafana.security.enabled=true --set grafana.security.usernameKey=username --set kiali.enabled=true --set grafana.security.passphraseKey=passphrase --set tracing.enabled=true --set prometheus.enabled=true</code></p>
<h4 id="6签发范域名证书得先把域名解析到istio-ingressgateway服务的外部地址">6.签发范域名证书(得先把域名解析到istio-ingressgateway服务的外部地址)</h4>
<pre><code>apiVersion: cert-manager.io/v1alpha2
kind: Certificate
metadata:
 name: ingress-cert
 namespace: istio-system
spec:
 secretName: ingress-cert
 issuerRef:
   name: letsencrypt
   kind: ClusterIssuer
 commonName: $INGRESS_DOMAIN
 dnsNames:
 - $INGRESS_DOMAIN
 acme:
   config:
   - http01:
       ingressClass: istio
     domains:
     - $INGRESS_DOMAIN
</code></pre>
<h4 id="检查签发成功的证书官方例子">检查签发成功的证书,<a href="https://istio.io/docs/tasks/traffic-management/ingress/ingress-certmgr/#getting-a-let-s-encrypt-certificate-issued-using-cert-manager">官方例子</a></h4>
<p><code>kubectl get certificate</code><br>
<img src="https://bibi520.github.io/post-images/1583908683044.jpg" alt="" loading="lazy"></p>
<h4 id="7网关使用证书">7.网关使用证书</h4>
<pre><code>apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: kiali-gateway
  namespace: istio-system
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 443
      name: https-kiali
      protocol: HTTPS
    tls:
      mode: SIMPLE
      serverCertificate: sds
      privateKey: sds
      credentialName: kiali-ingress-cert
    hosts:
    - &quot;xxx.example.com&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker-compose基础语法]]></title>
        <id>https://bibi520.github.io/post/docker-compose-ji-chu-yu-fa/</id>
        <link href="https://bibi520.github.io/post/docker-compose-ji-chu-yu-fa/">
        </link>
        <updated>2020-03-10T06:29:56.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">version</td>
<td style="text-align:center">指定docker-compose版本号</td>
</tr>
<tr>
<td style="text-align:left">services</td>
<td style="text-align:center">定义容器服务名字</td>
</tr>
<tr>
<td style="text-align:left">image</td>
<td style="text-align:center">指定服务的镜像</td>
</tr>
<tr>
<td style="text-align:left">command</td>
<td style="text-align:center">启动后指定的命令</td>
</tr>
<tr>
<td style="text-align:left">container_name</td>
<td style="text-align:center">定义容器名字</td>
</tr>
<tr>
<td style="text-align:left">depends_on</td>
<td style="text-align:center">解决容器依赖、先后启动问题</td>
</tr>
<tr>
<td style="text-align:left">network</td>
<td style="text-align:center">容器网络定义</td>
</tr>
<tr>
<td style="text-align:left">port</td>
<td style="text-align:center">容器映射的端口</td>
</tr>
<tr>
<td style="text-align:left">volume</td>
<td style="text-align:center">挂载卷</td>
</tr>
<tr>
<td style="text-align:left">labels</td>
<td style="text-align:center">定义标签</td>
</tr>
<tr>
<td style="text-align:left">extra_hosts</td>
<td style="text-align:center">往host文件写入主机名</td>
</tr>
<tr>
<td style="text-align:left">network_mode</td>
<td style="text-align:center">容器网络模式</td>
</tr>
<tr>
<td style="text-align:left">environment</td>
<td style="text-align:center">设置环境变量</td>
</tr>
<tr>
<td style="text-align:left">resources</td>
<td style="text-align:center">资源限制</td>
</tr>
<tr>
<td style="text-align:left">healthcheck</td>
<td style="text-align:center">健康检查机制</td>
</tr>
<tr>
<td style="text-align:left">logging</td>
<td style="text-align:center">配置日志服务</td>
</tr>
</tbody>
</table>
<p>还有很多  这里就不一一列举了 有兴趣的朋友可以去<a href="https://github.com/docker/docker.github.io/blob/master/compose/compose-file/index.md#deploy">github</a>查看</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[certbot签发范域名证书]]></title>
        <id>https://bibi520.github.io/post/certbot-qian-fa-fan-yu-ming-zheng-shu/</id>
        <link href="https://bibi520.github.io/post/certbot-qian-fa-fan-yu-ming-zheng-shu/">
        </link>
        <updated>2020-03-10T03:29:31.000Z</updated>
        <content type="html"><![CDATA[<h5 id="cerbot签发范域名证书中途还要做一次txt解析">cerbot签发范域名证书，中途还要做一次txt解析</h5>
<p><code>certbot certonly --manual --email xxx@qq.com --server https://acme-v02.api.letsencrypt.org/directory --agree-tos -d *.xx.com</code></p>
<h4 id="续签如报一下错误">续签如报一下错误:</h4>
<p>The manual plugin is not working; there may be problems with your existing configuration ......<br>
.....<br>
PluginError('An authentication script must be provided with --manual-auth-hook when using the manual plugin non-interactively.'</p>
<h4 id="解决方式说白了就是重新申请">解决方式（说白了就是重新申请）</h4>
<p><code>certbot certonly -d *.xxx.com --manual --preferred-challenges dns --server https://acme-v02.api.letsencrypt.org/directory</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[xpath基础语法]]></title>
        <id>https://bibi520.github.io/post/xpath-ji-chu-yu-fa/</id>
        <link href="https://bibi520.github.io/post/xpath-ji-chu-yu-fa/">
        </link>
        <updated>2020-03-10T03:14:21.000Z</updated>
        <content type="html"><![CDATA[<h4 id="选取节点">选取节点</h4>
<table>
<thead>
<tr>
<th style="text-align:left">表达式</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">nodename</td>
<td style="text-align:center">选取所有的nodename节点</td>
<td style="text-align:center">xpath('//div')</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:center">选取属于根节点的子节点</td>
<td style="text-align:center">xpath('/div')</td>
</tr>
<tr>
<td style="text-align:left">//</td>
<td style="text-align:center">选取当前的所有节点，不考虑位置</td>
<td style="text-align:center">xpath('//div')</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:center">选取当前节点</td>
<td style="text-align:center">xpath('./div')</td>
</tr>
<tr>
<td style="text-align:left">@</td>
<td style="text-align:center">选取符合属性的节点</td>
<td style="text-align:center">xpath('//@src')</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:center">选取nodename所有节点</td>
<td style="text-align:center">xpath('/div/*')</td>
</tr>
</tbody>
</table>
<h4 id="选取位置节点">选取位置节点</h4>
<table>
<thead>
<tr>
<th style="text-align:left">实例</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">xpath('/div/img[1]')</td>
<td style="text-align:center">选取div节点下的第一个img节点</td>
</tr>
<tr>
<td style="text-align:left">xpath('/div/img[last()]')</td>
<td style="text-align:center">选取div节点下最后一个img节点</td>
</tr>
<tr>
<td style="text-align:left">xpath('/div/img[last()-1]')</td>
<td style="text-align:center">选取div节点下的倒数第二个img节点</td>
</tr>
<tr>
<td style="text-align:left">xpath('/div/img[positon() &lt; 3]')</td>
<td style="text-align:center">选取div节点下前两个img节点</td>
</tr>
<tr>
<td style="text-align:left">xpath('/div/img[@class]')</td>
<td style="text-align:center">选取div节点下带有class属性的img节点</td>
</tr>
<tr>
<td style="text-align:left">xpath('/div/img[@class=&quot;txt&quot;]')</td>
<td style="text-align:center">选取div节点下class属性为txt的img节点</td>
</tr>
<tr>
<td style="text-align:left">xpath('//div | //table')</td>
<td style="text-align:center">选取所有的div和table节点</td>
</tr>
</tbody>
</table>
<h4 id="函数功能">函数功能</h4>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:center">实例</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">starts-with</td>
<td style="text-align:center">xpath('//div/[starts-with(@id,&quot;img&quot;)]')</td>
<td style="text-align:center">选取id的值以img开头的所有div节点</td>
</tr>
<tr>
<td style="text-align:left">contains</td>
<td style="text-align:center">xpath('//div/[contains(@id,&quot;img&quot;)]')</td>
<td style="text-align:center">选取id的值包含img的所有div节点</td>
</tr>
<tr>
<td style="text-align:left">and</td>
<td style="text-align:center">xpath('//div[contains(@id,&quot;img&quot;) and contains(@id,&quot;src&quot;)]')</td>
<td style="text-align:center">选取id的值包含img和src所有div节点</td>
</tr>
<tr>
<td style="text-align:left">text()</td>
<td style="text-align:center">xpath('//div/[contains(text(),&quot;img&quot;)]')</td>
<td style="text-align:center">选取节点文本包含img的所有div节点</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
</feed>